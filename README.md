# clean_code_VK

##Задача:
 
Реализовать простейший вариант алгоритма tf-idf.
 
Входные данные:
На вход программе поступают последовательно:
- Число N
- Далее в N строках - тексты документов. Будем называть номер документа в этом списке "docid"
- Число M - число запросов
- Далее M строк вида:
                                                   K <tab> $MODE <tab> Query...
Где K - число
$MODE == "AND" или "OR"
Query - произвольный текст запроса
K, $MODE и текст запроса разделены 1ой табуляцией
 
Нужно:
Каждому запросу подобрать <= K наиболее релевантных (т.е. с наибольшим score) документов и вывести в формате:
                                          $query <tab> $docid <tab> $score <tab> $snippet
Где
$query - повтор текста запроса
$docid - номер документа в списке
$score - оценка TF-IDF, см. ниже
$snippet - текст документа, если в нем меньше 50 символов, иначе - первые 50 символов и "..." (многоточие, без кавычек) после них
Все поля разделены 1ой табуляцией
 
 
Что такое TF-IDF?
Оценкой TF-IDF пары (запрос, документ) называется число, равное сумме по всем словам запроса произведения
 
sum_by_q_words: IDF_w * TF_w, где
IDF_w = -ln(count_docs_with_word / N) , N - общее число документов, count_docs_with_word - число документов с этим словом
TF_w = сколько раз слово w встречается в документе
 
Если MODE == "AND", то показываем документы где есть ВСЕ слова запроса. В случае "OR" - хотя бы одно из них.
 
Считаем, что в текстах запросов и документов нет \n, \t.
Считаем, что слова разделяются регуляркой (\W+). Приводим все к нижнему регистру.